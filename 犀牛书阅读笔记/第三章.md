# 第三章

js的数据类型分2类：原始类型和对象类型。

原始类型是：数字、字符串、布尔值，null和undefined。
对象类型是：属性的集合，包括：
- 对象：是属性的无序联合。
- 数组：是属性的有序联合。
- 函数
- 日期类
- 正则类
- 错误类

即js的数据类型为：string,number,boolen,null,undefined,object.
其中可分为可变类型和不可变类型，也可分为有方法的类型和没有方法的类型。

## 数字
### 1. 整型直接量
js的数字均采用浮点数来表示。
js能识别16进制值。也就是说数字直接量是以"0x"或"0X"为前缀，其后可以跟十六进制的直接量。
八进制的直接量有些js实现支持，有些不支持。在es6的严格模式下，八进制直接量是明令禁止的。

### 2. 浮点型直接量
例子可能更容易说明一些情况
```
3.14
23.123
.22123
6.02e23  // => 6.02*10^23
1.23e-23  // => 1.23*10^-23
```
使用指数计数法表示浮点型直接量，即在实数后跟字母e或E,后面再跟+或-号，再跟一个整形的指数。用来表示前面的实数乘以10的指数次幂。

### 溢出、下溢和非数字值
js有所能表现的数字的极限，在-2^53~2.53之间，包括临界值。
溢出：当数字运算的结果超出了js所能表示的数字上线时，就会溢出，返回一个特殊的值：Infinity。
下溢：当一个数字无限接近于0，但它又超出了js所能表示的最小值还小的时候，就会出现下溢，返回一个0。如果一个负数发生下溢，它会返回-0.

js有2个全局变量：Infinity和NaN。
Infinity用来表示正无穷大的值。
NaN用来表示非数字值。比如：0/0是返回NaN。NaN不等于任何值，也就说NaN == NaN 返回的是false。
只能通过NaN !== NaN 来判断，这个返回true.

-0和0是相等的，但当它们做分母时，会返回是-Infinity 和 +Infinity，这两个不等。


> NaN和null不一样。
NaN是一个数字直接量。
无穷大除以无穷大、给任意负数作开放运算、算术运算符与不是数字或无法转换为数字的操作数一起使用时，都将返回NaN。
null是一个对象，表示的是非对象的意思。


### 浮点数的四舍五入的误差
js采用2进制发来表示浮点数。
所以，可以精确的表示1/2,1/8,1/1024等数，但不能精确表示十进制的数，比如1/10,1/100，会出现四舍五入的误差。

如：
```
var x = 0.3 - 0.2;
var y = 0.2 - 0.1;
x == y  // => false
x == 0.1 // => false
y == 0.1 // => true
```
所以，如果涉及到钱的话，最小的单位是分，先把小数变成整数，再来进行计算。

## 文本

在混杂着HTML 和js的代码中。通常""双引号来表示HTML的代码。''单引号来表示js的代码。

- 可以通过\来将字符串分行
比如:
```one\
long\
world   // => one long world
```

- 如果要写can't时，可能会和''单引号解析错误，最好加\,即`can\'t`
- 转义字符\
如果一个字母前加\，可能就表示不同的意义了。比如\b，表示退格符。
而如果不在js的转义字符内，比如\x和x是等价的。


### 字符串的使用
字符串有很多种方法，这里就不一一枚举了，感觉和和数组的方法都很类似，字符串也相当于数组。每一个字符相当于数组的元素。
甚至，字符串的变量，可以通过数字的[]来进行引用。

## 布尔值
布尔值指代真假，只有true和false.
以下几个值都是假值：
- undefined
- null
- 0
- -0
- NaN
- "" // 空字符串

## null 和undefined
null是js语言的关键字，它表示一个特殊值，常用来描述“空值”。
tpyeof null,返回的出字符串“object”,也就是说，可以将null认为是一个特殊的对象值，含义是“非对象”。
但实际上，null通常被认为是它自有类型的唯一一个成员，它可以表示数字、字符串和对象是“无值”的。
undefined也表示值的空缺。用未定义的值表示更深层次的空值。

它是变量的一种取值，表示变量没有初始化。如果查询对象属性或数组元素的值时，返回undefined则说明这个属性或元素不存在。如果函数没有返回任何职，则返回undefined。

引用没有提供实参的值只会得到undefined。

你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺。

null表示程序级的、正常的或意料之中的值的空缺。

如果你想将它们赋值给属性或变量，或者将它们作为参数传入函数，最佳的选择是使用null。

## 全局对象
全局对象可以相当于保留字，全局对象的属性是全局定义的，js程序可以直接调用他们。
在代码段最顶级-不在任何函数内的js代码-可以使用js关键字this来引用全局对象：`var global = this ;`定义了一个引用全局对象的全局变量。

## 包装对象
字符串既然不是对象，为什么它会有属性？因为只要引用了字符串s的属性，js就会把字符串值通过new String()的方式先转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁。
包装对象是一种技术实现的细节。
```
var s = 'test';
s.len = 4;
var t = s.len; // 查询这个属性
```
当运行这个代码时，t的值是undefined。因为第二行s.len只是一个临时的值，随即销毁了这个对象。
第三行通过原始 字符串创建一个新字符串对象，常识读取其len属性，这个属性自然是不存在的。
但是`var t = s.len = 4;` t被赋值为了4，是成立的。

在存取字符串、数字或布尔值的属性时创建的临时对象称作包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。通常，包装对象只是被看做是一种实现细节，而不用特别关注。**由于字符串、数字和布尔值的属性都是只读的，并且不能给他们定义新属性。**

**包装对象**：在存取字符串、数字或布尔值的属性时创建的临时对象称作包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。



## 不可变的原始值和可变的对象引用
js中的原始值（null, undefined,boolean,number,string）与对象存在着根本的区别。
原始值不可更改：任何方法都无法更改一个原始值。
对数字和布尔值来说显然如此——改变数字的值本身就说不通，而对于字符串来说就不那么明显了，因为字符串看起来像是由字符组成的数组，我们期望通过制定索引来修改字符串中的字符。实际上，js是禁止这么做的。

字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。比如：

##### 对象和原始值的比较
原始值的比较是值的比较，比如数字、布尔值、null和defined。
而字符串的比较则不明显：如果两个单独的字符串进行比较，当且仅当他们的程度相等且每个索引的字符都相等时，js才认为他们是相等的。

- 对象的比较
对象的比较并非值的比较：既使两个对象包含的属性及相同的值，他们也是不相等的。各个索引元素完全相等的两个数组也不相等。

我们通常将对象称为引用类型，以此来和js的基本类型区分开来。依据术语的叫法，对象值都是引用，对象的比较均是引用的比较：当前仅当他们引用同一对象时，他们才相等。

```
var a = [];
var b = a;
b[0] = 3;
a[0]  // => 3;变量a的值也会改变。
```
将对象/数组赋值给一个变量，仅仅是赋值的引用知，对象本身并怎么复制一次。如果你想得到一个对象或数组的副本，则必须显式复制对象的每一个属性或数组的每个元素。

如果你想得到一个对象或数组的副本，则必须显式复制对象的每隔属性或数组的每隔元素。下面这个例子则通过循环来完成数组复制：
```
var a = ['a','b','c'];
var b = [];
for (var i = 0;i<a.length;i++;) {
    b[i] = a[i];
}
a == b //=> false，既使属性，值都一样，两个不同的数组也不一样。
```
同样的，如果我们想比较两个单独的对象或数组，则必须比较他们的属性或元素。下面这段代码定义了一个比较两个数组的函数：
```javaScript
function equalArrays(a,b) {
    if(a.length != b.length) retrun false;
    for (var i = 0;i<a.length;i++) {
        if(a[i]!== b[i]) return false;
    }
    return true;
}
```

**浅拷贝：**对简单数组/简单对象来说，浅拷贝是对值的复制。但对复杂对象/复杂数组（对象里嵌套数组/对象，数组里嵌套数组/对象）来说，浅拷贝是对地址的复制。也就是说，只能复制最上一层的数值，之后就是变为对地址的引用。如下：

```javascript
var obj = {a:1,b:{x:3,y:4}};
var shallowObj = {};
function shallowCopy(src) {
    var dist = {};
    for (prop in src) {
        if(src.hasOwnProperty(prop)) {
            dist[prop] = src[prop];
        }
    }
    return dist;
}

shallowObj = shallowCopy(obj);
shallowObj.b.x = 5;
shallowObj.a = 22;
console.log(shallowObj,obj);
```


## 类型转换
对象=>布尔值的转换，比较简单，所有对象都转换为true,对于包装对象也是如此。

对象=>字符串的转换。比较复杂，首先对用的是toString()方法，如果这个方法不行，则会选择valueOf()这个方法。
- [1,2,3] => '1,2,3'
- function x(a) {a = a+1 } => 'function x(a) {a = a+1 }'
- new Date(2010,0,1).toString() => 'Fri Jan 01 2010 00:00:00 GMT-0800(PST)'

对象=>数值的转换，调用的是valueOf()这个函数。

## 变量作用域
一个变量作用域（scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在js代码中的任何地方都是有定义的。然而在函数内声明的变量只在函数体内有定义。他们是局部变量，作用域是局部的。函数参数也是局部变量，他们只在函数体内有定义。

在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量遮盖。

**尽管全局作用域编写代码时可以不写var语句，但声明局部变量时则必须使用var语句。思考一下如果不这么做会怎样：**
```javascript
s = 'global';
function b() {
    s = 'local';
    mys = 'local';
    return [s,mys];
} 
b();
s;
mys;

```
> **在函数体内，如果不用var声明变量，那么这个变量就变成了全局变量。**

## 函数作用域和声明提前
**函数作用域**：变量在声明它们的函数以及这个函数体嵌套的任意函数体内都是有定义的。

声明提前，在一个函数体内，声明的所有变量都被提前至函数体 顶部，但不设计**赋值**。

## 作用域链

js是基于词法作用域的语言：通过阅读包含变量定义在内的数行源代码就能知道变量的作用域。全局变量在程序中始终是有定义的。局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。

如果将一个局部变量看做是自定义实现的对象的属性的话，那么可以换个角度来解读变量作用域。每一段js代码都有一个与之关联的作用域链。这个作用域链是一个对象列表或链表，这组对象定义了这段代码“作用域中”的变量。当js需要查找变量x的值的时候，它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，js会继续查找链上的下一个对象。如果这个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就会认为这段代码的作用域链上不存在x，并最终抛出一个引用错误。

在js的最顶层代码中，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有2个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解对象链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加到保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的链。

对于嵌套函数来讲，事情变得更为有趣，每次调用外部函数时，内部函数有回重新定义一遍。

因为每次调用调用外部函数时，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。

