{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[304],{143:function(e,t,n){\"use strict\";n.r(t);var r=n(0),i=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"div\",{staticClass:\"content\"},[n(\"h1\",{attrs:{id:\"buffer-more-ints-add-support-for-more-integer-widths-to-buffer\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#buffer-more-ints-add-support-for-more-integer-widths-to-buffer\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" buffer-more-ints: Add support for more integer widths to Buffer\")]),n(\"p\",[e._v(\"Node's Buffer only supports reading and writing integers of a limited\\nrange of widths.  This module provides support for more widths, so\\nthat integers from 1 to 8 bytes (64 bits) can be accessed.  The\\nsupport takes two forms. Firstly, as stand-alone functions similar to\\nthe integer reading/writing methods of Buffer:\")]),n(\"pre\",[n(\"code\",[e._v(\"$ node\\n> var moreints = require('buffer-more-ints')\\nundefined\\n> moreints.readInt64BE(new Buffer(\\\"0000deadbeef0000\\\", \\\"hex\\\"), 0).toString(16)\\n'deadbeef0000'\\n\")])]),n(\"p\",[e._v(\"Read and write functions for the regular widths (8, 16, 32) are also\\npresent in this module, for consistency.\")]),n(\"p\",[e._v(\"The second form is methods patched into \"),n(\"code\",[e._v(\"Buffer.prototype\")]),e._v(\", installed\\nby requiring \"),n(\"code\",[e._v(\"'buffer-more-ints/polyfill'\")]),e._v(\":\")]),n(\"pre\",[n(\"code\",[e._v(\"$ node\\n> require('buffer-more-ints/polyfill')\\n{}\\n> new Buffer(\\\"0000deadbeef0000\\\", \\\"hex\\\").readInt64BE(0).toString(16)\\n'deadbeef0000'\\n\")])]),n(\"p\",[e._v(\"buffer-more-ints/polyfill also adds methods \"),n(\"code\",[e._v(\"readIntBE\")]),e._v(\", \"),n(\"code\",[e._v(\"writeIntBE\")]),e._v(\",\\nand their LE and UInt counterparts, which take an initial argument\\ngiving the width of the integer in bytes:\")]),n(\"pre\",[n(\"code\",[e._v(\"> var b = new Buffer(3);\\n> b.writeIntLE(3, -123456, 0);\\n> b.toString('hex')\\n'c01dfe'\\n> b.readIntLE(3, 0);\\n-123456\\n\")])]),n(\"p\",[e._v(\"The functions added by buffer-more-ints are all implemented in terms\\nof the core Buffer functions.  Part way through writing the code, I\\ndiscovered that node.js currently implements those in JavaScript, so\\nthis doesn't lead to performance benefits.  But should node ever\\nswitch to implementing its Buffer operations natively, this\\nmodule should get a speed boost.\")]),n(\"h2\",{attrs:{id:\"limitations\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#limitations\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Limitations\")]),n(\"p\",[e._v(\"As JavaScript uses IEEE754 doubles for numbers, the contiguous range\\nof integers it can represent is [-2^53 - 1, 2^53 - 1].  So only\\ninteger widths up to 6 bytes or 48 bits can be read exactly.  Reads of\\n7 or 8 bytes (56 or 64 bits) will return the closest value that can be\\nrepresented as a JavaScript number.\")]),n(\"p\",[e._v(\"In certain situations it might be important to check that a JavaScript\\nnumber was read exactly.  The \"),n(\"code\",[e._v(\"isContiguousInt\")]),e._v(\" or\\n\"),n(\"code\",[e._v(\"Buffer.isContiguousInt\")]),e._v(\" (polyfill) function will determine this:\")]),n(\"pre\",[n(\"code\",[e._v(\"> Buffer.isContiguousInt(0x1fffffffffffff);\\ntrue\\n> Buffer.isContiguousInt(0x20000000000000);\\nfalse\\n\")])]),n(\"p\",[e._v(\"And \"),n(\"code\",[e._v(\"assertContiguousInt\")]),e._v(\" asserts that a number is so:\")]),n(\"pre\",[n(\"code\",[e._v(\"> Buffer.assertContiguousInt(0x1fffffffffffff);\\nundefined\\n> Buffer.assertContiguousInt(0x20000000000000);\\nAssertionError: number cannot be represented as a contiguous integer\\n\")])])])}],!1,null,null,null);t.default=i.exports}}]);","extractedComments":[]}