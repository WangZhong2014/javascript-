# 类和模块

如果若干个对象都继承自同一个原型，那么这些若干对象就具有相同的某些属性，也组成了此原型的同类对象。
而这个原型也就定义了一个js的类。

---
类：让某个对象都共享某些属性，这种共享的特性是非常有用的。
类的成员或实例都包含一些属性，用来存放或定义它们的状态，其中有些属性定义了它们的行为。

类的实现是基于其原型继承机制的。

如果2个实例都从同一个原型对象上继承了属性，我们说它们是同一类的实例。

## 类和原型
类的所有实例对象都从同一个原型对象上继承属性。原型是类的核心。

创建一个类的实例，首先是创建一个继承的对象，然后通过一个函数初始化这个新对象。
```js
function inherit(x) {
    return Object.create(x);
};

function range(from,to){
    var r = inherit(range.methods);

    r.from  = from,
    r.to = to;

    return r;
};

range.methods = {
    includes: function(x) {
        return this.from <=x && x<= this.to;
    },

    foreach: function (f) {
        for(var x = Math.ceil(this.from);x<=this.to;x++){
            f(x);
        }
    },

    toString: function() {
        return "(" + this.from + "..." + this.to + ')';
    }
}

var r = range(1,3);
console.log(r.includes(1));
console.log(r.toString());
```
上面的代码，this关键字都用来指代调用这个方法的对象。

## 类和构造函数
用构造函数来定义类，是最常见的方法。如下实例：
```js
function Range(from,to) {
    this.from = from,
    this.to = to
};

Range.prototype = {
    constructor: Range,
    includs: function(x) {
        return this.from <=x && x<= this.to;
    },

    foreach: function(f) {
        for(x = Math.ceil(this.from);x<=this.to;x++) {
            f(x);
        }
    },

    toString: function() {
        return "(" + this.from + "..." + this.to + ")"
    }
};

var r = new Range(1,3);
console.log(r.includs(2));
r.foreach(console.log);
console.log(r.toString());

// 这里预写了一个Range.prototype对象，这个新定义的原型对象不含有constructor属性。

//因此，Range类的实例也不含有constrcutor的属性。
//或者是，使用预定义的原型对象，预定义的原型对象包含constructor属性，然后依次给原型对象添加方法：
Range.prototype.includs = function(x) {
    return this.from <=x && x<= this.to;
};
Range.prototype.foreach = function(f) {
    for(x = Math.ceil(this.from);x<=this.to;x++) {
        f(x);
    }
};
Range.prototype.toString = function() {
    return "(" + this.from + "..." + this.to + ")"
};
console.log(Range === Range.prototype.constructor)
```

- 构造函数是必须要通过New关键字来进行调用的。
- 在调用构造函数之前，就已经新创建了一个对象，通过this关键字可以获取这个新对象。
- 构造函数的原型属性，必须是强制命名:Range.prototype.对Range()构造函数的调用会自动使用Range.prototype作为新Range对象的原型,并进行初始化。

---
调用构造函数生成新对象的工作流：
1. `var a = new Range()`，首先一点，必须要有new关键字，先生成一个新空对象，这个对象自动绑定到this上，即是上下文，同时调用构造函数Range()对空对象进行初始化。
2. 初始化之后，会自动调用Range.prototype，这个对象从Range.prototype继承属性。

**构造函数：**
```js
var x = new Range(){
    //构造函数就是用来新创建对象的，最开头必须是有一个new关键字，首先是声明了一个对象，并将这个绑定到了this上，之后再调用Range()函数，初始化新建对象的属性和状态。

    //同时，构造函数的Range也需要有一个Range.prototype属性，这里面是定义类的共享的属性和方法。同样的，新创建的对象，也被绑定到了this上。可以通过this来获得引用新对象。
};
```

### 构造函数和类的标识
原型对象是类的唯一标识：当且仅当2个对象继承自同一个原型对象时，它们才是属于同一个类的实例。

而构造函数不能当做类的标识,但构造函数是类的公用标识。

#### constructor属性

每个js函数都都自动拥有一个prototype属性，这个属性的值是一个对象，这个对象包含一个不可枚举的属性constructor,constructor属性的值是一个函数对象。
```js
var F = function() {}；
var p = F.prototype;
var c = p.constructor;
console.log(F === c) ; // true
```
可以看出，`F.prototype.constructor`就是F。也就是说，对象继承的constructor值就指代它们的构造函数。


## JavaScript中Java式的类继承
js中的类牵扯三种 不同的对象，三种对象的属性行为和下面三种类成员非常相似：

- 构造函数对象：为js类定义了名字。任何添加到这个构造函数对象中的属性都是类字段和类方法。
- 原型对象：原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用。
- 实例对象：类的每个实例都是一个独立的对象。

在js中，定义类的步骤可以缩减为分三步的算法。
1. 先定义一个构造函数，并设置初始化新对象的实例属性。
2. 给构造函数的prototype对象定义实例的方法。
3. 给构造函数定义类字段和类属性。

```js
var extend = function(o) {
    for (i= 1,len = arguments.length; i<len;i++) {
        var source = arguments[i];
        for(prop in source){
              o[prop] = source[prop] 
        };
    }
};

function defineClass(
    constructor,methods,statics
) {
    if(methods) extend(constructor.prototype,methods);
    if(statics) extend(constructor,statics);
    
    
    return constructor;
};

var SimpleRange = defineClass(
    function(f,t) {
    this.f = f,
    this.t = t
    },
    
    {
        includs: function(x) {
            return this.f <=x && x<= this.to;
        },
        tostring: function() {
            return '(' + this.f + '...' + this.to +')'
        }
    },
    {
        // upto:function(t) {
        //     return new SimpleRange(-1,t);
        // }
    }
)

var s= new SimpleRange(1,2);
console.log(s);
```

### 类的扩充
