# 类和模块

如果若干个对象都继承自同一个原型，那么这些若干对象就具有相同的某些属性，也组成了此原型的同类对象。
而这个原型也就定义了一个js的类。
而这些对象，就是这个类的实例。

---
类：让某个对象都共享某些属性，这种共享的特性是非常有用的。
类的成员或实例都包含一些属性，用来存放或定义它们的状态，其中有些属性定义了它们的行为。

类的实现是基于其原型继承机制的。

如果2个实例都从同一个原型对象上继承了属性，我们说它们是同一类的实例。

## 类和原型
类的所有实例对象都从同一个原型对象上继承属性。原型是类的核心。

创建一个类的实例，首先是创建一个继承的对象，然后通过一个函数初始化这个新对象。
```js
function inherit(x) {
    return Object.create(x);
};

function range(from,to){
    var r = inherit(range.methods);

    r.from  = from,
    r.to = to;

    return r;
};

range.methods = {
    includes: function(x) {
        return this.from <=x && x<= this.to;
    },

    foreach: function (f) {
        for(var x = Math.ceil(this.from);x<=this.to;x++){
            f(x);
        }
    },

    toString: function() {
        return "(" + this.from + "..." + this.to + ')';
    }
}

var r = range(1,3);
console.log(r.includes(1));
console.log(r.toString());
```
上面的代码，this关键字都用来指代调用这个方法的对象。

## 类和构造函数
用构造函数来定义类，是最常见的方法。如下实例：
```js
function Range(from,to) {
    this.from = from,
    this.to = to
};

Range.prototype = {
    constructor: Range,
    includs: function(x) {
        return this.from <=x && x<= this.to;
    },

    foreach: function(f) {
        for(x = Math.ceil(this.from);x<=this.to;x++) {
            f(x);
        }
    },

    toString: function() {
        return "(" + this.from + "..." + this.to + ")"
    }
};

var r = new Range(1,3);
console.log(r.includs(2));
r.foreach(console.log);
console.log(r.toString());

// 这里预写了一个Range.prototype对象，这个新定义的原型对象不含有constructor属性。

//因此，Range类的实例也不含有constrcutor的属性。
//或者是，使用预定义的原型对象，预定义的原型对象包含constructor属性，然后依次给原型对象添加方法：
Range.prototype.includs = function(x) {
    return this.from <=x && x<= this.to;
};
Range.prototype.foreach = function(f) {
    for(x = Math.ceil(this.from);x<=this.to;x++) {
        f(x);
    }
};
Range.prototype.toString = function() {
    return "(" + this.from + "..." + this.to + ")"
};
console.log(Range === Range.prototype.constructor)
```

- 构造函数是必须要通过New关键字来进行调用的。
- 在调用构造函数之前，就已经新创建了一个对象，通过this关键字可以获取这个新对象。
- 构造函数的原型属性，必须是强制命名:Range.prototype.对Range()构造函数的调用会自动使用Range.prototype作为新Range对象的原型,并进行初始化。

---
调用构造函数生成新对象的工作流：
1. `var a = new Range()`，首先一点，必须要有new关键字，先生成一个新空对象，这个对象自动绑定到this上，即是上下文，同时调用构造函数Range()对空对象进行初始化。
2. 初始化之后，会自动调用Range.prototype，这个对象从Range.prototype继承属性。

**构造函数：**
```js
var x = new Range(){
    //构造函数就是用来新创建对象的，最开头必须是有一个new关键字，首先是声明了一个对象，并将这个绑定到了this上，之后再调用Range()函数，初始化新建对象的属性和状态。

    //同时，构造函数的Range也需要有一个Range.prototype属性，这里面是定义类的共享的属性和方法。同样的，新创建的对象，也被绑定到了this上。可以通过this来获得引用新对象。
};
```

### 构造函数和类的标识
原型对象是类的唯一标识：当且仅当2个对象继承自同一个原型对象时，它们才是属于同一个类的实例。

而构造函数不能当做类的标识,但构造函数是类的公用标识。

#### constructor属性

每个js函数都自动拥有一个prototype属性，这个属性的值是一个对象，这个对象包含一个不可枚举的属性constructor,constructor属性的值是一个函数对象。
```js
var F = function() {}；
var p = F.prototype;
var c = p.constructor;
console.log(F === c) ; // true
```
可以看出，`F.prototype.constructor`就是F。也就是说，对象继承的constructor值就指代它们的构造函数。


## JavaScript中Java式的类继承
js中的类牵扯三种 不同的对象，三种对象的属性行为和下面三种类成员非常相似：

- 构造函数对象：为js类定义了名字。任何添加到这个构造函数对象中的属性都是类字段和类方法。
- 原型对象：原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用。
- 实例对象：类的每个实例都是一个独立的对象。

在js中，定义类的步骤可以缩减为分三步的算法。
1. 先定义一个构造函数，并设置初始化新对象的实例属性。
2. 给构造函数的prototype对象定义实例的方法。
3. 给构造函数定义类字段和类属性。

```js
var extend = function(o) {
    for (i= 1,len = arguments.length; i<len;i++) {
        var source = arguments[i];
        for(prop in source){
              o[prop] = source[prop] 
        };
    }
};

function defineClass(
    constructor,methods,statics
) {
    if(methods) extend(constructor.prototype,methods);
    if(statics) extend(constructor,statics);
    
    
    return constructor;
};

var SimpleRange = defineClass(
    function(f,t) {
    this.f = f,
    this.t = t
    },
    
    {
        includs: function(x) {
            return this.f <=x && x<= this.to;
        },
        tostring: function() {
            return '(' + this.f + '...' + this.to +')'
        }
    },
    {
        upto:function(t) {
            return new SimpleRange(s,t);
        }
    }
)

var s= new SimpleRange(1,2);
console.log(s);
```

### 类的扩充
js基于原型的继承机制是动态的：对象是从其原型继承属性，如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象。

这意味着我们可以通过给原型对象添加新方法来扩充js的类。
```js
Number.prototype.times = function(f,context) {
    var n = Number(this);
    for (var i = 0; i < n; i ++) {
        f.call(context, i);
    };
};

var n = 3;
n.times(function(n) {
    console.log(n + 'hello');
});

String.prototype.trim = String.prototype.trim || function() {
    if(!this){return this};
    return this.replace(x,'');
};

Function.prototype.getName = function() {
    return this.name || this.toString().match()
};

```

可以给Object.prototype添加方法，从而使所有的对象都可以调用这些方法。
但这些并不推荐，因为可以被for/in被枚举到。不过可以通过Object.defineProperty()方法可以安全地扩充Object.prototype.

### 类和类型

#### instanceof 运算符
左操作数是待检测类型的对象，右操作数是定义类的构造函数。

如果o继承自c.prototype,则`o instanceof c = true`
如果o继承自另一个对象b，而b继承自c,这个等式依然成立。

构造函数是类的公共标识，但原型是唯一的标识。

#### constructor 属性
识别对象是否属于另一类的方法是使用constructor 属性。比如：
```js
function typeAndValue (x) {
    if (x == null ) return '';
    switch(x.constructor) {
        case Number: return 'Number: ' + x;
        case String: return 'String: ' + x;
        case Date: return 'Date: ' + x;
        case RegExp: return 'RegExp: ' + x;
        case Complex: return 'Complex: ' + x; 
    }
}
```

#### 构造函数的名称

isntanceof运算符和consctructor属性来检测对象所属的类有一个主要的问题，在多个执行上下文中存在构造函数的多个副本时，这两种方法会检测错误。多个执行上下文中的函数看起来是一模一样的，但它们是独立的对象。

所有，可以通过匹配函数的名字来判定是否是属于同一类。
```js
function type(o) {
    var t,c,n;

    if (o === null ) return 'null';
    if (o !== o) return 'NaN';
    if((t = typeof o) === 'object') return t;
    if((c = classof(o)) === 'Object') return c;
    if(o.constructor && typeof o.constructor === "function" &&
    (n = o.constructor.getName())) return n;

    return "Object";
}

function classof(o) {
    return Object.prototype.toString.call(o).slice(8,-1);
};

Function.prototype.getName = function() {
    if('name' in this) return this.name;
    return this.name = this.toString().match(/function\s*([^(]*)\(/)[1];
}

var a = function() {
    x+y;
};

console.log(type(a));
```

#### 鸭式辩论
不要关注对象的类是什么，而关注对象能做什么。
也即：
> 像鸭子一样走路，游泳并且嘎嘎叫的鸟就是鸭子。

continue 和case语句复习
```js
for (var i = 0; i<10; i ++) {
    switch(i) {
    case 1:
      a = 10;
      console.log(a);
    case 2:
      a = 20;
      console.log(a);
      continue;
      case 3: 
      a = 30;
      console.log(a);
    }

}
```

quacks()函数：
```js
function quacks(o) {
    for(var i = 1;i<arguments.length;i++) {
        var arg = arguments[i];
        switch(typeof arg) {
        case 'string': if (typeof o[arg] !== 'function') return false;
        continue;
        case 'function': arg = arg.prototype;
        case 'object':
        for(var m in arg) {
            if (typeof arg[m] !== 'function')continue;
            if (typeof o[m] !== 'function')
            return false;
        }
        }
    }
    return true;
}
```

关于quacks():
- 它不能应用于内之类的。
- 不能通过quacks(o,Array)来检测o是否实现了Array中所有同名的方法，因为许多内置类的方法都是不可枚举的。

