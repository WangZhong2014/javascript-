## 第四章 表达式与运算符
**表达式**：是js中的一个的短语。
将简单表达式组合成复杂表达式最常用的方法就是使用运算符。**运算符**按照特定的运算规则对操作数进行运算，并计算出新值，运算符返回一个值。

**原始表达式**：原始表达式是表达式的最小单位。比如直接量，如字符直接量，数字直接量，正则表达式直接量。

第二种原始表达式是保留字，如true,false,null,this。
第三种原始表达式是变量。

### 1. 对象和数组的初始化表达式
和对象直接量、数组直接量没有太大的区别。
数组直接量的元素列表结尾处可以留下单个逗号，这时并不会创建一个新的值。

### 2. 函数定义表达式
定义一个js函数。
可以通过函数定义表达式，也可称为“函数直接量”
```javascript
var a = function(x) {
    x = x+1;
}
```
### 3. 属性访问表达式
属性访问表达运算得到一个对象属性或一个数组元素的值。
- 对象属性访问表达式有2中语法：
 1. expression.identifier 
 2. expression[expressson] //方括号里面的expresson必须是一个字符串或者必须是一个返回字符串的表达式。不过如果属性是一个数字的话,表达式则可以直接是一个数字直接量。`var a = {13:"dkdk"},a[13]  // =>返回"dkdk"`，但不能写成`a.13`


- 数组属性访问表达式：
 1. expression[expresson] // 方括号内必须是数字或是返回数字的表达式才行，也就是说[expresson]是数组中元素的索引。

**当属性名是通过运算得出的值而不是固定的值的时候，必须使用方括号的写法。**
**当属性名是一个保留字或包含空格和标点符号，或者数字的时候，则必须使用方框或写法。**

### 4. 对象创建表达式
对象创建表达式创建一个对象并调用一个函数初始化对象的属性。


## 算数表达式

1. w = x = y = z; 这个表达式的运算顺序是：w = (x = (y = z))，从右到做进行运算

### 加法运算符（+）
```javascript
1 + 2  // => 3
1 + "2" // =>12
'1' + '2' // => 12
1 + null // => 1
1 + undefined  // => NaN
```
> 如果操作数中有一个是字符串，那么会优先进行字符串的加法运算。
如果操作数两个都不是字符串，则会转换成数字来进行运算。

- 加法运算符是从左到右的运算顺序。


#### 递增操作符
递增运算符对其操作数进行增量操作，操作数是一个左值。运算符将操作数转换为数字，然后给这个数字加1，并将加1后的数值重新复制给变量、数组元素或者对象属性。

递增运算符的返回值依赖于它相对于操作数的位置。
当运算符在操作符之前，称为“前增量”，它对操作数进行增量计算，并返回计算后的值。
当运算符在操作符之后，称为“后增量”，它对操作数进行增量计算，但返回未做增量计算的值。
```javascript
var i = 1;
console.log(i++);
console.log(++i);
console.log(i) // =>3 ,i的值被改变了2次。但i++返回的是未改变之前的值。
```


#### 关系表达式
1. js对象的比较是引用的比较，不是值的比较。对象和其本身是相等的，但和其他任何对象都不相等。如果两个不同的对象具有相同数量的属性，相同的属性名和值，它们依然是不相等的。相应位置的数组元素是相等的两个数组也是不相等的。
2. 尽量用恒等运算符，而不要用相等运算符。

3. 当是字符串比较时，js的字符串是一个由16位整数值组成的序列，字符串的比较也只是两个字符串中的字符的数值的比较。
 - 注意，所有大写的ASCII字母都“小于”小写的ASCII字母。如果不注意这条不起眼的规则，会有小麻烦。比如“Zoo”小于“arrdvasr”,返回的是true.

4. 字符串的比较，用String.localCompare()方法来获取更多字符串比较的相关信息，这个方法也更加健壮可靠。对于那些不需分字母大小写的比较来说，需要先把字符串全部换成小写或大写字母，用String.toLowerCase()和String.toUpperCase()。
5. 对于数字和字符串操作符来说，加号运算符（+）和比较运算符有所不同。+更偏爱字符串，如果它的其中一个操作数是字符串的话，则进行字符串连接操作。
6. 比较运算符则更偏爱数字，如果在两个操作数都是字符串的时候，才会进行字符串的比较。

看如下例子：
```1 == true  // => true 
2 == false  // => false
3 == true   // => false，这里应该是true先换算成数字，true是1，false是0，之后再进行比较。 
```

#### 等于运算符（==）和严格等于（===）运算原则

**比较运算符则更偏爱数字，如果在两个操作数都是字符串的时候，才会进行字符串的比较。如果比较的类型不一样，都会优先转换成数字再进行比较。**

===：
1. 如果两个值的类型不一样，那么它们不相等。
2. 如果两个值都是null或undefin，它们不相等。
3. 如果两个值都是布尔值true/false,它们相等。
4. 如果其中一个值是NaN，或两个值都是NaN，那么，它们不相等，也就是说NaN和任何值都不相等，包括它本身！只能通过x!== x来判断x是否为NaN，只有在x为NaN的时候，这个表达式的值才是true;
5. 如果两个值为数值且数值相等，则它们相等。如果a = 0,b = -0，则它们相等。
6. 如果它们引用值指向同一个对象、数组或函数，则它们相等。如果指向不同的对象，则它们不等，尽量两个对象有相同一样的属性。

==:
1. 如果两个操作数的类型相同，则和严格相等的比较规则一样。如果严格相等，则它们相等，如果不严格相等， 则它们不相等。
2. 如果操作数书类型不一样，则会先进行转换：
   - 如果一个值是null，一个是undefined，则它们相等。
   - 如果一个值是数字，一个是字符串，字符串会先转换成数字，然后再使用转换的值进行比较。
   - 如果其中一个值是true，则将其先转换成1再进行比较。如果其中一个值是false，则现将其转换为0进行比较。
   - 如果一个值是对象，另一个值是数字或字符串。对象将先转换成原始值，再进行比较。

#### in运算符
in运算符希望它的左操作数是一个个字符串或可以转换成字符串，希望它的有操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回true.
```javascript
var point = {x:1, y:1}
"x" in point // => true
"y" in point // => true
x in point // 报错，x为undefined,本质上，x是变量标识符，不能担当直接量
```

当右边的操作数是一个数组时，左操作数是一个字符串，但也可以是一个数字，会先把数字转换成字符串再进行操作。左边的操作数是数组的索引。
```javascript
var a = [22,1,2,,,3];
'0' in a // => true,数造包含元素，故而索引0是存在的。
1 in a  // =>true,数字先转换成字符串'1',再进行计算，a包含3个元素，索引1也存在数字。
3 in a // => false ,数组没有索引为3的的元素。
2 in a // => true,数组有索引为2的元素。 
```

#### instanceof运算符
instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右操类的实例，则返回true,否则返回false。右操作数应该是一个函数。
```
var d = new Data();
d instanceof Data; // => true; d 由Data()创建。
d instanceof Object // => true; 所有的对象都是Object的实例。
d instanceof Number // => false. d不是Number对象

var a = [1,2,3];
a instanceof Array; // =>true
```
所有的对象都是Object的实例。当通过instanceof判断一个对象是否是一个类的实例的时候，这个判断也会包含对“父类”的检测。如果instanceof的左操作数不是一个对象的话，instanceof也会返还一个false。如果右操作数不是函数，则会抛出一个类型错误异常。


### 逻辑表达式
#### 逻辑与（&&）
1. 操作数不一定是布尔值，可以是能够被当做真值和假值的表达式或原始值或对象类型。
2. &&可以对真值和假值进行布尔与操作。
3. &&首先计算左侧的表达式。如果计算结果是假值，那么整个表达式的结果一定是假值，因此&&这时简单地返回左操作数的值，而不会对右操作数进行计算。如果左操作数是真值，那么整个表达式的结果依赖于右操作数的值。如果右操作数是真值，那么整个表达式的值一定是真值:
  - 当左操作数是假值的时候，返回左操作数的值，不计算右边的值。
  - 当左操作数是真值的时候，返回右操作数的值。

#### 逻辑或（||）
逻辑或与逻辑与很想。||运算符对两个操作数做布尔或运算，如果其中一个或两个操作数是真值，它返回一个真值。如果两个操作数都是假值，它返回一个假值。
- 它首先会计算第一个操作数的值，也就是说会首先操作左侧的表达式。如果计算结果为真值，那么返回这个真值。
- 否则，再计算第二个操作数的值，即计算右侧的表达式，并返回这个表达式的结果。
```javascript
var preferences = {
    max_width : 0
}
var max_width = 0;
var max = max_width || preferences.max_width || 500;
console.log(max); // => 500;在真值和假值中，数字0是false，而字符串'0'则是真值。这里是需要注意的。
```

**关系表达式优先级比逻辑表达式运算优先级高**

#### 逻辑非（！）
！运算符具有非常高的优先级，并且和操作数紧密绑定在一起。也就是说，！总厨返回true或false。

## 赋值表达式
1. = 具有非常低的优先级，通常是最后才进行运算。
2. 赋值操作符的结核性是从右到左，也就其说，如果一个表达式中出现了多个赋值运算操作符，运算顺序是从右到左。
   `i = j = k = 0; `
### 带操作的赋值运算
通常是：
`a op= b => a = a op b;`op是运算符。

## 表达式计算
**eval：**js同样可以解释运行由js源代码组成的字符串并产生一个值。js通过全局函数eval()来完成这个工作。
- 动态判断源代码中的字符串是一种强大的语言特性，几乎没有必要再实际中运用。如果你使用了eval(),应当仔细考虑是否有必要使用它。

#### eval()
eval()只有一个参数，如果传入的参数不是一个字符串，它讲返回这个参数。
如果这个参数是一个字符串，它会把这一段字符串当成js代码进行编译。
如果编译失败，则会抛出一个语法错误（SyntaxError）,如果编译成功，则开始执行这段代码。
如果最后一个表达式或语句没有值，则总重返回vundefined。

#### 全局eval()
eval()具有改变局部变量的能力。当通过别名调用时，eval()会将其字符串当成顶层的全局代码来执行。

也就是说。当直接使用非限定的“eval”名称了调用eval()函数时，统称为直接"eval"。直接调用eval()时，它总是在调用它的上下文作用域内执行。

*其他的间接调用则使用全局对象作为其上下文作用域，并且无法读、写、定义局部变量和函数。*
> 我试验了一下， 在node中，发现通过别名调用是不可行的。可能现在已经一起在严格模式下了。
也就是说：
1. 不能通过别名来覆盖eval()函数，变量名、函数名，函数参数都不能取名为eval。也不能让geval = eval，然后再通过geval()来调用eval(),只能通过eval()使用。
2. 严格模式下，eval()执行的代码段可查询或更改局部变量，但不能在局部作用域中定义新的变量或函数。



## 条件运算符(?:)
这个是唯一的一个三元运算符。
第一个操作数是布尔值，第二、三个操作数是表达式。
如`x>0?x:-x`。如果x>0为真值，那么执行的是？和:之间的表达式，如果x>0是假值，那么执行:号之后的表达式。

greeting = 'hello' + (username ? username : 'there');

## typeof 运算符
typeof是一元运算符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。
需要注意的是：
typeof null 返回的是 object
typeof NaN 返回的是 number
typeof undefined 返回的是 undefined
数组和对象都返回的是object。
所有可执行的对象进行typeof运算都返回function

`instanceof`运算符，是左边是对象名（变量名/标识符），右边是对象的类，返回的布尔值。

## delete运算符
1. delete用来删除对象属性或数组元素。delete也是有副作用的，它是用来删除操作的，并不会返回一个值。
```javascript
var a = [1,2,3];
delete a[2];
2 in a; // false:索引为2的元素已经被删除了。
a.length  // =>3，长度并没有改变。
2. 用户通过var语句声明的变量是不可被删除的。一些核心和客户端属性是不能被删除的。通过function语句定义的函数和函数参数也是不能被删除的
```

## void运算符
void是一元运算符，它出现在操作数之前，操作数可以是任意类型。这个运算符并不是经常使用：操作数会照常计算，但忽略计算结果并返回undefined。void会忽觉操作数的值，因此在操作数具有副作用的时候使用void来让程序更具语义。

## 逗号运算符
逗号运算符是一个二院运算符，它的操作数可以是任意类型。它首先计算左操作数，然后计算右操作数，最后返回右操作数的值。在for循环中是比较常见的。