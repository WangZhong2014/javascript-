# 正则表达式的模式匹配
正则表达式是一个描述字符模式的对象。js的RegExp类表示正则表达式，String和RegExp都定义了方法，否则使用正则表达式进行强大的模式匹配和文本检索与替换功能。


## 10.1 正则表达式的定义。
正则表达式用RegExp对象表示，可以使用RegExp()构造函数来创建RegExp()对象。
同样，ReaExp对象也可以使用特殊的直接量语法来创建。
如：`var pattern = /s$/;`
这段代码创建一个新的RegExp对象，并将它赋值给变量pattern。

### 10.1.1 直接量字符
正则表达式中的所有字母和数字都是按照字面含义进行匹配度。
- 字母和数字字符匹配自身
- 有许多标点符号具有特殊含义，如果想在正则表达式中表示这些字符的直接量进行匹配，则必须使用前缀\，否则就会当成是一个特殊的含义进行匹配。
- 许多字母在\做前缀时也有特殊含义，所以对于想按照直接量进行匹配的字母和数字，尽量不要使用反斜线对其转义。
- 如果想要在正则表达式中按照直接量匹配反斜线本身，就必须使用反斜线将其转义。 `/\\/`用来匹配任何包含反斜线的字符串。

|字符|匹配|
|-|-|-|
|字母和数字字符|自身|
|\0|NUL字符|
|\t|字表符|
|\n|换行符|
|\v|垂直制表符|
|\f|换页符|
|\r|回车符|
|\xnn|由16进制数nn指定的拉丁字符|
|\uxxxx|由16进制数xxxx指定的Unicode字符|
|\cX|控制字符^X|


### 10.1.2 字符类
- 将直接量字符单独放进方括号里面就组成了字符类。一个字符类可以匹配它所包含的任意字符。[abc]表示任何包含a,b,c的字符。
- 可以使用`^`来表示否定字符柴总，它匹配所有不包含在放括号内的字符。
- 可以使用连字符来表示字符范围。/[a-z]/,匹配拉丁字母中任何小写字母。/[a-zA-Z0-9]/匹配拉丁字母表中任何字母和数字。

|字符|匹配|
|-|-|
|[...]|方括号内的任意字符|
|[^...]|不在方括号内的任意字符|
|.|除换行符和其他Unicode行终止符之外的任意字符|
|\w|等价于[a-zA-Z0-9]|
|\W|等价于[^a-zA-z0-9]|
|\s|任何Unicode空白符，即空格|
|\S|任何非Unicode空白符的字符|
|\d|任何ASCII数字，等价于[0-9]|
|\D|任何非ASCII数字，等价于[^0-9]|
|[\b]|退格直接量|

### 10.1.3重复
我们在正则表达式之后跟随用以指定字符重复的标记。
由于某些重复种类非常常用，因此就又一些专门用于表示这种情况的特殊字符。

|字符|匹配|
|-|-|
|{n,m}|匹配前一项至少n次，但不能超过m次|
|{n,}|匹配前一下n次或者更多次|
|{n}|匹配前一项n次|
|?|匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0,1}|
|+|匹配前一项1次或多次，等价于{1,}|
|*|匹配前一项0次或多次，等价于{0,}|

```js
/\d{2,4}/ // 匹配2~4个数字
/\w{3}\d?/ // 匹配三个单词和1个可选的数字
/\s+java\s+/ // 匹配前面带有1个或多个空格的字符串'java'
/[^(]*/ // 匹配一个或多个不是(的字符。

```
正则表达式是用以匹配变量的，也即符合正则表达式的变量，将被筛选出来。

#### 非贪婪的重复
上述内容的匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配。我们称之为“贪婪的匹配”。

同样，我们可以使用正则表达式进行非贪婪的匹配。只需在待匹配的字符后跟随一个问号即可：
`?? +? *?`或者`{1,5}?`。如：
/a+/可以匹配一个或多个连续字母a.当使用'aaa'作为匹配字符串时，正则表达式也会匹配它的三个字符。
但是/a+?/也可以匹配一个或多个连续字母a。若将'aaa'作为匹配字符串，它匹配的是第一个a.
```js
'aaab' 进行/a+b/ => 'aaab'
'aaab' 进行/a+?b/ => 'ab'
```
正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。

### 10.1.4 选择、分组和引用
正则表达式还可以包括指定选择项、子表达式分组和引用前一表达式的特殊字符。

**选择项**的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。
/a|ab/ 匹配'ab'时，匹配的是a.

**分组**
正则表达式的圆括号有多种作用。
- 把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用"|","*","+","?"等来对单元内的项进行处理。
/java(script)?/ =>java或javascript
/(ab|cd)+|ef/ =>ab或cd出现多次，或ef。

- **在完整的模式中定义子模式。**
当一个正则表达式成功的与目标字符串匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。
如：
`/[a-z]+\d+/`表示，一个或多个小写字母后面跟着1个或多个数字，筛选出来的结果是字母+数字。
`(/[a-z]+(\d+)/)`表示，一个或多个小写字母后面跟着的，1个或多个数字，筛选出来的结果是数字。

- 带圆括号的表达式的另一个用途是允许同一正则表达式的后部引用前面的字表达式。通过在字符\后面加1位或多位数字来实现。这个数字指定了带圆括号的子表达式在正则表达式的位置。\1引用的是第一个带圆括号的子表达式，\3引用的是第三个带圆括号的子表达式。
**注意：**子表达式可以嵌套另一个子表达式，所以它的位置是参与计数的左括号的位置。
`/([Jj]ava([Ss]cript?)\sis\s(fun\w*))/` 中的([Ss]cript?)可以用\2来表示。

- 对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。
如/(['"])[^'"]*\1/ 。\1引用的是['"]所匹配的结果，重新在后面进行匹配。这里，左边的引号必须和右侧的引号相匹配。

- 正则表达式不允许用双引号括起来的内容中有单引号，反之亦然。所以下面的写法是非法的：
`/(['"])[^\1]\1/`因为\1是匹配(['"])所匹配的结果。所以，如果\1是单引号',那么[^\1]就是指不是单引号的任何字符，可以是双引号"，但这不符合正则表达式的规则。

- 正则表达式中，不用创建带数字编码的引用，也可以对子表达式进行分组。可以用(?:[Ss]cript)来进行，这仅指分组。

|字符|含义|
|-|-|
|\||选择，匹配的是该符合左边的子表达式或右边的字表达式，左表达式匹配成功后，就不会再进行右表达式了|
|(...)|组合，将几个项组合为一个单元，这个额但愿可通过* + ? | 等符号进行加以修饰，而且可以记住这个组合相匹配的字符串以供后面的引用，引用的数字是以左括号的顺序来进行的|
|(?:...)|只组合，把项组合到一个单元，但不记忆与该组相匹配的字符|
|\n|和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式，组索引是从左到右的左括号数，不包括(:?形式的分组编码|

### 10.1.5 指定匹配位置

- \s匹配的只是一个空白符
- \b匹配的是一个单词的边界，即位于\w字符和\W之间的边界。\b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。

最常见的锚元素是^,它用来匹配字符串的开始，$用于匹配字符串的结束。

- 任何正则表达式都可以作为锚点条件。如果在符号'(?=' 和')'之间加入一个表达式（这里的表达式只用于指定一个位置，它是零宽的）。它就是一个先行断言，用以说明圆括号内的表达式必须正确匹配，但并不是真正意义上的匹配。如：
`/[Jj]ava([Ss]cript)?(?=\:)/`,这个正则表达式可以匹配"Javascript: the definitive guide"，而不能匹配"Java in a Nutshell",因为Java后面并没有冒号。

带有"(?!" 的断言是负向先行断言，用以指定接下来的字符都不必匹配。
`/Java(?! Script)([A-Z]\w*)/`。它可以匹配'JavaBeans'但不能匹配'Java Script'。

|字符|含义|
|-|-|
|^|匹配字符串的开头，在多行检索中，匹配一行的开头|
|$|匹配字符串的结尾，在多行检索中，匹配一行的结尾|
|\b|匹配一个单词的边界|
|\B|匹配非单词边界的位置|
|(?=p)|零宽正向先行断言，要求接下面的字符都与p匹配，但不能包括匹配p的哪些字符|
|(?!p)|零宽负向先行断言，要求接下来的字符不与p匹配|


### 10.1.6 修饰符
正则表达式的修饰符，用以说明高级匹配模式的规则。修饰符是放在/符号之外的。

js支持3个修饰符。

|字符|含义|
|-|-|
|i|执行不区分大小写的匹配|
|g|执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止|
|m|多行匹配模式，^匹配一行的开头和字符串的开头，$匹配行的结束和字符串的结束，然后m要求每行都是如此|

## 10.2

#### search()方法。
返回第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，则返回-1.

如果()内不是正则表达式，则首先会通过RegExp构造函数将它转换成正则表达式，search()方法不支持全局检索，会忽略修饰符g。

#### replace()方法。
用于执行检索与替换操作。其中第一个参数是一个正则表达式，第二个参数是要进行替换的字符串。
如
`text.replace(/javascript/ig,"JavaScript")`，是将text中的所有不区分大小写的javascript，替换成区分大小写的JavaScript.
```js
text = "你说呢:'123';";
var quote = /'([^"']*)'/g;
var b= text.replace(quote, '- “$1” -');
```

#### match()方法
它的唯一参数就是一个正则表达式，返回的是一个由匹配结果组成的数组。如果该正则表达式设置了修饰符g，则该方法返回的数组扩韩字符串中的所有匹配结果。比如：
`'1 plus 2 equals 3'.match(/\d+/g)` 返回的结果是[1,2,3];

如果这个正则表达式没有修饰符g，match()就不会进行全局检索，它只会检索第一个匹配，但即使match(执行的不是全局检索，它也会返回一个数组a。那么a[0]存放的是完整匹配，a[1]喷绘的是与第一个元括号阔气来的表达式相匹配的字符串。
```js
var url = /(\w+):\/\/([\w.]+)\/(\S*)/;

var text = "Visit my blog at http://www.example.com/~david";
var result = text.match(url);

if (result !=null) {
    var fullurl = result[0];
    var pro = result[1];
    var host = result[2];
    var c = result[3];
};

console.log(result);
```

#### 字符串String的split()方法。

`'1123,4,1,2,4'.split(',');`=>通过','符号把字符串分割。返回[ '1123', '4', '1', '2', '4' ];

split()方法的参数可以是一个正则表达式，这使得split()方法异常强大。比如:
```js
var a= '1, 2, 3, 222,  ,';
b= a.split(/\s*,\s*/);
console.log(b);
```
这个正则表达式允许两边留有任意多的空白符。

### 10.3 RegExp对象
RegExp()构造函数有2个字符串参数，第二个参数是可选的。
第一个参数是正则表达式的主题部分，即2斜杠//之间的内容。
第二个参数是正则表达式的修饰符。
```js
var  a = new RegExp('\\d{5}','g');
var b= 'abcdef';
var c= b.match(a);
console.log(c);
```
通过字符串表述的正则表达式时，\必须替换成\\。因为字符串也是通过\字符作为转义字符的前缀。
故而"\d{5}"通过字符串来进行传入时，则是"d{5}";(\d在字符串中被自动转换为d了)


- RegExp()构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没有办法通过写死在代码中的正则表达式直接量来实现。

### 10.3.1 RegExp属性
RegExp对象包含5个属性。
- source包含正则表达式的文本。
- global是一个只读的布尔值，用以说明这个正则表达式是否包含修饰符g。
- ignoreCase，也是只读，用以说明是否带有i。
- multiline，只读，用于说明是否带有m。
- lastIndex,是一个可读写的证书。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置，这个属性会被exec()和test()用到。

### 10.3.2 RegExp方法

**exec()方法**
这个方法是和String的match()很类似，不过exec(),调用它的是一个正则表达式对象，()里面填入的参数是一个字符串。和String的match()是反过来的。

exec()对一个指定的字符串执行一个正则表达式。
- 如果没有找到任何匹配，就返回null。
- 如果而找到一个匹配，就会返回一个数组。和match不同的是，不论带不带g，exec()都会返回一样的数组，包含index，和input,以及()里面所带的子表达式所匹配的字符串。
```js
var  a = new RegExp('\d{5}',"g");
var b= 'ddddd，dddd';
var c= b.match(a);
console.log(a.source,c);
console.log('-------------');
var d = a.exec(b);
console.log(d);
```
- 相比之下，exec()总是返回一个完整的结果，并提供关于本次匹配的完整信息。当exec()的正则表达式对象包含g时，它讲把当前正则表达式对象的lastIndex属性设置为紧挨着匹配子串的字符位置，。当同一个正则表达式第二次调用exec()时，它 将从lastIndex属性所知的字符串处开始检索。

- 如果exec()没有发现任何匹配结果，它讲会lastIndex重置为0.
```js
var a= /Java/g;
var text = 'JavaScript is more fun than Java';

var result;

while((result = a.exec(text)) !== null ) {
    console.log("Matched '" + result[0] + "' " + "at posotion " + result.index + "; next search begins at " + a.lastIndex);
};

```

**test()方法**，它比exec()更简单一些。它的参数是一个字符串，用来对某个字符串进行检测， 如果包含正则表达式的一个匹配结果，就返回true,没有则返回false；

调用exec()和test()等阶，当一个全局正则表达式调用test()方法时，因为它从lastIndex指定的位置处开始检索某个字符串，如果它找到了一个匹配结果，那么它就立即设置lastIndex为当前匹配子串的结束位置。

String方法的search(),replace()和match()并不会用到index属性。实际上，String方法只是简单的将lastIndex属性值设置为0。

- 如果让一个带有修饰符g的正则表达式对多个字符串执行exec()或test()，那么在每隔字符串中找到所有匹配一遍将lastINdex自动重置为0.如果忘记手动设置lastIndex，那么会从上次检索的位置开始检索。