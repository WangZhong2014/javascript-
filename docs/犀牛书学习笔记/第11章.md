# js的子集和扩展

## 子集
大多数语言都会定义它们的子集，用以更安全地执行不可信的第三方代码。
有些子集则是简化了这门语言，规避掉语言中的怪癖、缺陷部分，最终使编程更轻松，程序更健壮。

### 11.1.1 精华
在 《JavaScript: The Good Parts》中，去掉了js中的一些不稳定因素：
- 不包括with和continue语句和eval()函数。
- 不包括逗号运算符，位运算符和"++","--"。
- 比较时，使用'===' 和 '!=='。
- var语句只能出现在函数体的顶部。并要求程序猿将函数内的所有变量声明卸载一条单独的var 语句中。

### 11.1.2 子集的安全性
这里讨论一个更大的子集：
- eval()和Function()构造函数在任何安全自己都是禁止使用的。
- 禁止使用this关键字。
- 禁止使用with语句。
- 禁止使用某些全局变量。
- 禁止使用某些属性和方法。比如_proto_.
- 防止带有.运算符的属性存取表达式去读写特殊属性。

目前的一些实现：
- ADsafe
- dojox.secure
- Caja
- FBJS
- Microsoft Web SandBox

## 11.2 常量和局部变量

### 常量const
const声明的变量，是不可重复赋值的变得，对常亮的重复声明会报错。
```js
const pi = 3.14;
pi = 4 // => 会被忽略
const pi = 4; // 会报错
```
常亮会被提前至函数定义的顶部。

### 块级作用域 let
let有4种使用方式：
- 可以作为变量声明，和var一样。
- 在for/forin循环中，作为var的替代方案。
- 在语句块中定义一个新变量并显式指定它的作用域。

与var的不同：
- var声明的变量在函数内都是可用的，而let声明的变量则只属于就近的花括号括起来的语句块。
- 在循环体内使用let声明的变量，在循环体外是不可用的。
- let创建的变量的作用域仅限于循环体、循环条件判断逻辑和自增操作表达式。
```js
function letTest() {
    let x = 1;
    if (true) {
      let x = 2;  // 不同的变量
      console.log(x);  // 2
    }
    console.log(x);  // 1
  };
```

- let并不会像var一样在全局对象上创造一个属性.
- 在相同的函数或块作用域内重新声明同一个变量会引发SyntaxError。
```js
if (x) {
  let foo;
  let foo; // TypeError thrown.
}
```

### 11.3 结构赋值
当发生解构赋值时，右侧的数组和对象中一个或多个的值就会被提取出来，并赋值给左侧相应的变量名。
```js
let [x,y] = [1,2];//=> x= 1,y=2;
[x,y] = [y,x]; //= >x=y,y=x;
```

解构赋值右侧的数组不需要和左侧的变量一一对应，左侧多余的变量的赋值为undefined，右侧多余的赋值会被海豚。

整个解构赋值运算的返回值是右侧的整个数据结构，而不是从中提取出来的某个值。
```js
let a ,b,c;
a = [b,c] = [1,2,3,4];
```
- 解构赋值，左右侧的数组解构必须一样。

- 这使得可以将值从数组或属性从对象提取到不同的变量中。
```js

({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20


// Stage 3 proposal
({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
console.log(a); // 10
console.log(b); // 20
console.log(rest); //{c: 30, d: 40}
var [a, ...b] = [1, 2, 3];
console.log(a); // 1
console.log(b); // [2, 3]
```



